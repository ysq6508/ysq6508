# js 中数组常用的方法
1. 增：push()、unshift()、splice(开始下标，结束下标)返回被切割下来的新数组、concat()
2. 删：pop()、shift()、splice()、slice()
3. 查：indexOf()、include、find()、lastIndexOf()
4. 迭代：forEach()、map()、reduce()、every()、some()、filter()
5. 转换：join()、[reverse()操作原数组、toReversed()返回新数组]注意两者区别、sort()

# js 中字符串常用的方法
1. 增：concat()
2. 删：substring()跟数组上的slice一样、slice()
3. 改：replace('c', '1')返回新数组、
       trim()返回新数组，只能删最左侧或最右侧的空格
       toUpperCase()、toLowerCase()、
       padStart(10, '0')强行填充指定元素至指定长度、padEnd(10, '0') -> 大整数相加：转成字符串、位数小的前面填充0
4. 查：charAt()返回指定下标上的数组、startsWith()是否以指定字符开头、endsWith()是否以指定字符结尾、
        indexOf()子字符串在原字符串中首次出现的位置、lastIndexOf()
        match()返回匹配到的正则表达式、search
5. 转换：split()转数组      (ps:Number()强转数字，但不是字符串身上的)

# 谈谈js中的类型转换机制
- 介绍：js中有7种原始类型和引用类型之分，在开发时有时候我们需要人为地将一个变量的类型转换为其他类型，这种转换称之为 显示转换，有时候js引擎也会发生隐式转换

- 方式：
    1. 显示： 直接用构造函数Number()、String()...强转
              pardeInt('123', 2)转换出十进制， 第二个参数告诉js引擎是几进制的，不写默认为10进制
    2. 隐式：通常发生在比较运算符，算术运算符

- [] == ![]
    引用类型转原始类型 [] == false
    '' == 0
    0 == 0  => true

# == VS ===
    == 只判断值是否相等，不在乎类型，v8会发生隐式类型转换
    === 判断是否全等，不发生类型转换

# 聊聊js中的拷贝问题
- 介绍：开发中经常面对一个要跟原对象得到一个新对象的场景，这种场景我们称之为拷贝
通常我们聊拷贝只在引用类型身上，原始类型上谈论拷贝没有意义(因为原始类型直接存在栈里面)

- 特点：
    1. 浅拷贝：得到的新对象受原对象修改的影响
    2. 深拷贝：得到的新对象 不 受原对象修改的影响

- 方法：
    1. 浅拷贝：Object.create()、Object.assign()、{...obj}解构
               [...arr]、concat、slice、 arr.toReversed().reverse()
        浅拷贝的手写实现
    2. 深拷贝：
        - JSON.parse(JSON.stringify(obj)) 无法处理 bigInt，Symbol，undefined类型，无法处理循环引用   (5.2.js)

        - structuredClone 也不能拷贝Symbol和function

        - new MessageChannel(); (5.4.js)
        深拷贝的手写实现

# 说说闭包
- 是什么
    闭包是一个存储一些变量的集合。根据作用域的规则，内层函数可以访问外层函数，当内层函数拿到外层函数之外被调用时，即使外层函数执行完也不能完全被销毁，留下内层函数需要用到的变量集合，那个集合就是闭包

- 缺点：内存泄漏：栈当中存储空间越来越少。(当你写了一百个闭包，栈内存就满了，导致程序崩溃)
- 优点：定义私有变量，防止全局变量污染，便于封装模块

- 应用场景：
 1. 防抖节流
 2. 单例模式(一个页面只能有要弹出不同内容弹出框，但是我只会写并复用一个弹出框)
 3. 柯里化（一种很优雅的编程范式）：把一个接收多个参数的函数体，变成多个接收一个参数的函数体
